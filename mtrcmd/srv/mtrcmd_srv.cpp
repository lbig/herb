// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MTRcmd.h"

#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>


#include "stdio.h"
#include <string>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace std;

static bool _check(const MTRcmdReq &query) {
	bool ret = true;
	if (query.cmd.empty()) {
		ret = false;
	}
	return ret;
}

static void _fillerr(MTRcmdRes &_return, const string &err) {
	_return.status = -1;
	_return.error = err;
}


class MTRcmdHandler : virtual public MTRcmdIf {
 public:
  MTRcmdHandler() {
    // Your initialization goes here
  }

  void mtrcmd(MTRcmdRes& _return, const MTRcmdReq& query) {
    // Your implementation goes here
    printf("mtrcmd\n");
	
	if (!_check(query)) {
		string err = "cmd is null!";
		_fillerr(_return, err);
		return ;
	}
	
	string cmd = query.cmd;
	FILE *pp = popen(cmd.c_str(), "r");
	if (!pp) {
		string err = "cmd exec fail!";
		_fillerr(_return, err);
		return ;
	}

	char buff[2048];
	while (fgets(buff, sizeof(buff), pp) != NULL) {
/*
		if (buff[strlen(buff) - 1] == '\n') {
			buff[strlen(buff) - 1] = '\0'; //去除换行符
		}
*/
		_return.info.append(buff);
	}
	_return.status = 0;
	return ;
  }

};

int main() {
  int port = 3344;
  shared_ptr<MTRcmdHandler> handler(new MTRcmdHandler());
  shared_ptr<TProcessor> processor(new MTRcmdProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

